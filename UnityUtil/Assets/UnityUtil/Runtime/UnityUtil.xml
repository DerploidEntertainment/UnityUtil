<?xml version="1.0"?>
<doc>
    <assembly>
        <name>UnityUtil</name>
    </assembly>
    <members>
        <member name="T:UnityUtil.BuildAutomation.BuildManifest">
            <summary>
            Represents a Unity Build Automation (UBA) build manifest, for runtime parsing of the JSON manifest provided by UBA.
            See the <a href="https://docs.unity.com/ugs/en-us/manual/devops/manual/build-automation/build-automation-integrations/use-build-automations-build-manifest-during-runtime">UBA build manifest docs</a>
            for more info.
            </summary>
        </member>
        <member name="P:UnityUtil.BuildAutomation.BuildManifest.ScmCommitId">
            <summary>
            The commit or changelist that was built.
            </summary>
        </member>
        <member name="P:UnityUtil.BuildAutomation.BuildManifest.ScmBranch">
            <summary>
            The name of the branch that was built.
            </summary>
        </member>
        <member name="P:UnityUtil.BuildAutomation.BuildManifest.BuildNumber">
            <summary>
            The Build Automation build number corresponding to this build.
            </summary>
        </member>
        <member name="P:UnityUtil.BuildAutomation.BuildManifest.BuildStartTime">
            <summary>
            The UTC timestamp when the build process started.
            </summary>
        </member>
        <member name="P:UnityUtil.BuildAutomation.BuildManifest.ProjectId">
            <summary>
            The Unity project identifier.
            </summary>
        </member>
        <member name="P:UnityUtil.BuildAutomation.BuildManifest.BundleId">
            <summary>
            The bundleIdentifier configured in Build Automation (iOS and Android only).
            </summary>
        </member>
        <member name="P:UnityUtil.BuildAutomation.BuildManifest.UnityVersion">
            <summary>
            The version of Unity that Build Automation used to create the build.
            </summary>
        </member>
        <member name="P:UnityUtil.BuildAutomation.BuildManifest.XcodeVersion">
            <summary>
            The version of XCode used to build the Project (iOS only).
            </summary>
        </member>
        <member name="P:UnityUtil.BuildAutomation.BuildManifest.CloudBuildTargetName">
            <summary>
            The name of the build target that was built.
            </summary>
        </member>
        <member name="F:UnityUtil.DependencyInjection.DependencyInjector._injectedTypes">
            <summary>
            This collection is only a field (rather than a local var) so as to reduce allocations in <see cref="M:UnityUtil.DependencyInjection.DependencyInjector.getDependeciesOfMethod(System.String,System.Reflection.MethodBase,System.Reflection.ParameterInfo[])"/>
            </summary>
        </member>
        <member name="M:UnityUtil.DependencyInjection.DependencyInjector.#ctor(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            DO NOT USE THIS CONSTRUCTOR. It exists purely for unit testing
            </summary>
        </member>
        <member name="M:UnityUtil.DependencyInjection.DependencyInjector.registerService(UnityUtil.DependencyInjection.Service,System.Nullable{UnityEngine.SceneManagement.Scene})">
            <summary>
            Register <paramref name="service"/> present in <paramref name="scene"/>
            </summary>
            <exception cref="T:System.InvalidOperationException">
            A <see cref="T:UnityUtil.DependencyInjection.Service"/> with the provided <see cref="F:UnityUtil.DependencyInjection.Service.ServiceType"/> and <see cref="F:UnityUtil.DependencyInjection.Service.InjectTag"/> has already been registered.
            </exception>
        </member>
        <member name="P:UnityUtil.DependencyInjection.DependencyInjector.CachedResolutionTypes">
            <summary>
            <para>
            Use these rules to cache commonly resolved dependencies, speeding up Scene load times.
            We use this whitelist approach because caching ALL dependency resolutions could use up significant memory, and could actually
            worsen performance if many of the dependencies were only to be resolved by one client.
            </para>
            <para>
            After a class instance with one of these types has had its dependences resolved via reflection,
            the reflected metadata and matching services will be cached, so that
            subsequent clients of the same type will have their dependencies injected much faster.
            This is useful if you know you will have many client components in a scene with the same type.
            </para>
            </summary>
        </member>
        <member name="P:UnityUtil.DependencyInjection.DependencyInjector.RecordingResolutions">
            <summary>
            Toggles recording how many times service <see cref="T:System.Type"/>s are resolved at runtime, for optimization purposes.
            </summary>
        </member>
        <member name="P:UnityUtil.DependencyInjection.DependencyInjector.ServiceResolutionCounts">
            <summary>
            Gets/sets the number of times that each service <see cref="T:System.Type"/> has been resolved at runtime.
            </summary>
        </member>
        <member name="M:UnityUtil.DependencyInjection.DependencyInjector.Construct``1">
            <summary>
            Attempts to construct an instance of <typeparamref name="T"/>, using the constructor with the most parameters that
            can all be resolved from registered services. If no constructors can have all parameters resolved, then <see langword="null"/> is returned.
            </summary>
            <typeparam name="T">Type of object to be constructed.</typeparam>
            <returns>The constructed instance of <typeparamref name="T"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Could not resolve all dependencies (parameters) of any public constructor on <typeparamref name="T"/>.</exception>
        </member>
        <member name="M:UnityUtil.DependencyInjection.DependencyInjector.Construct(System.Type)">
            <summary>
            Attempts to construct an instance of <paramref name="clientType"/>, using the constructor with the most parameters that
            can all be resolved from registered services. If no constructors can have all parameters resolved, then <see langword="null"/> is returned.
            </summary>
            <returns>The constructed instance of <paramref name="clientType"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Could not resolve all dependencies (parameters) of any public constructor on <paramref name="clientType"/>.</exception>
        </member>
        <member name="M:UnityUtil.DependencyInjection.DependencyInjector.ResolveDependenciesOf(System.Object)">
            <summary>
            Inject all dependencies into the specified client.
            Can be called at runtime to satisfy dependencies of procedurally generated components, e.g., by a spawner.
            </summary>
            <param name="client">A client with service dependencies that need to be resolved.</param>
        </member>
        <member name="M:UnityUtil.DependencyInjection.DependencyInjector.getDependeciesOfMethod(System.String,System.Reflection.MethodBase,System.Reflection.ParameterInfo[])">
            <summary>
            Resolve the dependencies of <paramref name="method"/>.
            I.e., get the service that satisfies the <see cref="T:System.Type"/> and (optional) tag of each of <paramref name="method"/>'s parameters.
            </summary>
            <param name="clientName">Name of the client object instance on which <paramref name="method"/> can be called</param>
            <param name="method">The method for which to resolve dependencies.</param>
            <param name="parameters"><paramref name="method"/>'s parameters, if they have already been loaded via reflection.</param>
            <returns>The dependencies (parameters) required by <paramref name="method"/>.</returns>
        </member>
        <member name="T:UnityUtil.DependencyInjection.InjectTagAttribute">
            <summary>
            Inject the service configured with this field's <see cref="T:System.Type"/> and an optional Inspector tag.
            </summary>
        </member>
        <member name="M:UnityUtil.DependencyInjection.InjectTagAttribute.#ctor(System.String)">
            <summary></summary>
            <param name="tag">The service <see cref="T:UnityEngine.Object"/> with this tag (set in the Inspector) will be injected.  Use when registering multiple services with the same Type.</param>
        </member>
        <member name="P:UnityUtil.DependencyInjection.InjectTagAttribute.Tag">
            <summary>
            The service <see cref="T:UnityEngine.Object"/> with this tag (set in the Inspector) will be injected.  Use when registering multiple services with the same Type.
            </summary>
        </member>
        <member name="T:UnityUtil.DependencyInjection.ITypeMetadataProvider">
            <summary>
            This type is used internally by the DI system. You should never need to implement it in your own code.
            </summary>
        </member>
        <member name="F:UnityUtil.DependencyInjection.Service.InjectTag">
            <summary>
            Tag to disambiguate services of the same <see cref="F:UnityUtil.DependencyInjection.Service.ServiceType"/>.
            </summary>
        </member>
        <member name="T:UnityUtil.IRuntimeIdProvider">
            <summary>
            Provides methods for getting a unique identifier at runtime
            </summary>
        </member>
        <member name="M:UnityUtil.IRuntimeIdProvider.GetId">
            <summary>
            Get a new, unique identifier. Every call to this method at runtime is guaranteed to return a new integer,
            but different integers may be generated during each run.
            </summary>
            <returns>A new, unique identifier.</returns>
        </member>
        <member name="T:UnityUtil.Logging.BaseUnityUtilLogger`1">
            <summary>
            Base class for custom loggers in <see cref="N:UnityUtil"/> components.
            Derived types can define methods that provide statically-typed parameters to specific log messages
            and abstract away their log levels and other log properties.
            </summary>
            <typeparam name="TCategoryName">The type that is logging. It's type name will be appended as the "category" of all its log messages.</typeparam>
            <remarks>
            <para>
            Defining all log messages in a single class means that developers only have to look within a single type
            to find log <see cref="T:Microsoft.Extensions.Logging.EventId"/> conflicts, inconsistent log property names, inconsistent language/grammar, etc.
            It also provides a single type to modify when migrating log frameworks
            (though this is less of an issue with the <see cref="N:Microsoft.Extensions.Logging.Abstractions"/> namespace).
            </para>
            <para>
            Each method of a derived class should be referenced by at most one call site;
            if a method is no longer referenced then it should be deleted, effectively deleting its inner log message.
            </para>
            <para>
            Every log message must have a unique integer ID, so that specific messages can be searched in log files and storage systems.
            This means that all log events are sharing the same "space" of event IDs, both within components of the <see cref="N:UnityUtil"/> namespaces,
            and the components of your own application.
            To prevent conflicts, we divide this space into six "subspaces" or "ranges" for each <see cref="T:Microsoft.Extensions.Logging.LogLevel"/>, with 100,000,000 unique IDs each.
            </para>
            These ID ranges are:
            <list type="table">
                <listheader>
                    <term>Log level</term>
                    <term>ID Range Start</term>
                    <term>ID Range End</term>
                </listheader>
                <item>
                    <term><see cref="F:Microsoft.Extensions.Logging.LogLevel.Trace"/></term>
                    <term>0</term>
                    <term>99,999,999</term>
                </item>
                <item>
                    <term><see cref="F:Microsoft.Extensions.Logging.LogLevel.Debug"/></term>
                    <term>100,000,000</term>
                    <term>199,999,999</term>
                </item>
                <item>
                    <term><see cref="F:Microsoft.Extensions.Logging.LogLevel.Information"/></term>
                    <term>200,000,000</term>
                    <term>299,999,999</term>
                </item>
                <item>
                    <term><see cref="F:Microsoft.Extensions.Logging.LogLevel.Warning"/></term>
                    <term>300,000,000</term>
                    <term>399,999,999</term>
                </item>
                <item>
                    <term><see cref="F:Microsoft.Extensions.Logging.LogLevel.Error"/></term>
                    <term>400,000,000</term>
                    <term>499,999,999</term>
                </item>
                <item>
                    <term><see cref="F:Microsoft.Extensions.Logging.LogLevel.Critical"/></term>
                    <term>500,000,000</term>
                    <term>599,999,999</term>
                </item>
            </list>
            <para>
            Each namespace of <see cref="N:UnityUtil"/>, then, is given 1,000 unique event IDs to work with in each <see cref="T:Microsoft.Extensions.Logging.LogLevel"/>-subspace (by default),
            starting from some "base offset".
            For example, the event ID offset of the <see cref="N:UnityUtil"/> root namespace is 0,
            so it can use information event IDs 200,000,000 - 200,000,999 and warning event IDs 300,000,000 - 300,000,999.
            Likewise, if the event ID offset of another namespace is 1000,
            then it can use information event IDs 200,001,000 - 200,001,999 and warning event IDs 300,001,000 - 300,001,999.
            In other words, a namespace's event ID offset sets the lowest offset relative to the start of each <see cref="T:Microsoft.Extensions.Logging.LogLevel"/>-range that a namespace can use.
            </para>
            <para>
            The authoritative list of namespace event ID offsets is maintained in the <a href="https://github.com/DerploidEntertainment/UnityUtil">UnityUtil repo</a>.
            You <i>must</i> avoid using event IDs that collide with these ranges when creating new log messages in libraries that reference <see cref="N:UnityUtil"/>,
            so that you don't pass these conflicts on to consumers.
            If you are only referencing <see cref="N:UnityUtil"/> in an application, then you <i>should</i> still avoid ID collisions;
            ID collisions will not break your application's logging, but they will make it more difficult to search for specific logs.
            </para>
            <b>Note to Inheritors</b>
            <para>
            Inheriting from this class will make all of the above ID-management easier.
            The <see cref="M:UnityUtil.Logging.BaseUnityUtilLogger`1.#ctor(Microsoft.Extensions.Logging.ILoggerFactory,`0,System.Int32)"/> constructor accepts an offset parameter,
            and your custom log methods can use it by calling the <see langword="protected"/> <see cref="M:UnityUtil.Logging.BaseUnityUtilLogger`1.Log(System.Int32,System.String,Microsoft.Extensions.Logging.LogLevel,System.String,System.Object[])"/> meethod.
            That way, your custom log methods can all use simple monotonically increasing event IDs (0, 1, 2, etc.),
            and the actual integer value is computed (<see cref="T:Microsoft.Extensions.Logging.LogLevel"/>- and namespace-offsets added) in one place.
            </para>
            <para>
            By convention, the custom logger for each <see cref="N:UnityUtil"/> namespace is a class called <c><![CDATA[<Namespace>Logger]]></c> within that namespace.
            See the namespaces in this repo for examples.
            </para>
            <para>
            When using dependency injection, consumers should not inject this class or any of its derived types directly.
            Instead, consumers should inject <see cref="T:Microsoft.Extensions.Logging.ILoggerFactory"/> and new up these types <i>in-situ</i> explicitly.
            Otherwise, the recommendation would be to create an interface for the custom logger <i>and</i> an implementing type,
            and that would just create a lot of friction when adding a new log message.
            </para>
            </remarks>
        </member>
        <member name="M:UnityUtil.Logging.BaseUnityUtilLogger`1.#ctor(Microsoft.Extensions.Logging.ILoggerFactory,`0,System.Int32)">
            <summary>
            Creates a new instance of <see cref="T:UnityUtil.Logging.BaseUnityUtilLogger`1"/>
            </summary>
            <param name="loggerFactory">Used to create the internal <see cref="T:Microsoft.Extensions.Logging.ILogger`1"/> instance</param>
            <param name="context">Object to which the log messages apply.</param>
            <param name="eventIdOffset">This offset will be added to all logged event IDs, to ensure unique IDs across all systems.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="eventIdOffset"/> is negative, not a multiple of <see cref="F:UnityUtil.Logging.BaseUnityUtilLogger`1.ComponentAllowedIdCount"/> greater than the highest allowed offset for a single <see cref="T:Microsoft.Extensions.Logging.LogLevel"/>
            </exception>
        </member>
        <member name="F:UnityUtil.Logging.BaseUnityUtilLogger`1.LogLevelAllowedIdCount">
            <summary>
            The max number of log event IDs that each <see cref="T:Microsoft.Extensions.Logging.LogLevel"/> may use.
            </summary>
            <remarks>
            Note to contributors: BEWARE!! Changing this value is a SERIOUS BREAKING CHANGE, altering most of the log <see cref="T:Microsoft.Extensions.Logging.EventId"/>s generated by this library.
            </remarks>
        </member>
        <member name="F:UnityUtil.Logging.BaseUnityUtilLogger`1.ComponentAllowedIdCount">
            <summary>
            The max number of log event IDs that each <see cref="N:UnityUtil"/> component (namespace or referencing library) may use.
            </summary>
            <remarks>
            Note to contributors: BEWARE!! Changing this value is a SERIOUS BREAKING CHANGE, altering most of the log <see cref="T:Microsoft.Extensions.Logging.EventId"/>s generated by this library.
            </remarks>
        </member>
        <member name="F:UnityUtil.Logging.BaseUnityUtilLogger`1.BaseEventIdTrace">
            <summary>
            Base event ID for <see cref="F:Microsoft.Extensions.Logging.LogLevel.Trace"/> logs.
            </summary>
        </member>
        <member name="F:UnityUtil.Logging.BaseUnityUtilLogger`1.BaseEventIdDebug">
            <summary>
            Base event ID for <see cref="F:Microsoft.Extensions.Logging.LogLevel.Debug"/> logs.
            </summary>
        </member>
        <member name="F:UnityUtil.Logging.BaseUnityUtilLogger`1.BaseEventIdInformation">
            <summary>
            Base event ID for <see cref="F:Microsoft.Extensions.Logging.LogLevel.Information"/> logs.
            </summary>
        </member>
        <member name="F:UnityUtil.Logging.BaseUnityUtilLogger`1.BaseEventIdWarning">
            <summary>
            Base event ID for <see cref="F:Microsoft.Extensions.Logging.LogLevel.Warning"/> logs.
            </summary>
        </member>
        <member name="F:UnityUtil.Logging.BaseUnityUtilLogger`1.BaseEventIdError">
            <summary>
            Base event ID for <see cref="F:Microsoft.Extensions.Logging.LogLevel.Error"/> logs.
            </summary>
        </member>
        <member name="F:UnityUtil.Logging.BaseUnityUtilLogger`1.BaseEventIdCritical">
            <summary>
            Base event ID for <see cref="F:Microsoft.Extensions.Logging.LogLevel.Critical"/> logs.
            </summary>
        </member>
        <member name="M:UnityUtil.Logging.BaseUnityUtilLogger`1.LogTrace(System.Int32,System.String,System.String,System.Object[])">
            <summary>
            Formats and writes a log message at <see cref="F:Microsoft.Extensions.Logging.LogLevel.Trace"/> level,
            with the specified <paramref name="id"/> and <paramref name="name"/>.
            </summary>
            <param name="id">
            Unique ID <i>within the logging namespace</i>.
            The <see cref="F:Microsoft.Extensions.Logging.LogLevel.Trace"/> and namespace event ID offsets will be automatically appended
            </param>
            <param name="name">
            Distinctive (ideally unique) human-readable name for the log event.
            The name of the custom log method is usually preferrable (using <see langword="nameof"/>).
            </param>
            <param name="message">Format string of the log message.</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
        </member>
        <member name="M:UnityUtil.Logging.BaseUnityUtilLogger`1.LogDebug(System.Int32,System.String,System.String,System.Object[])">
            <summary>
            Formats and writes a log message at <see cref="F:Microsoft.Extensions.Logging.LogLevel.Debug"/> level,
            with the specified <paramref name="id"/> and <paramref name="name"/>.
            </summary>
            <param name="id">
            Unique ID <i>within the logging namespace</i>.
            The <see cref="F:Microsoft.Extensions.Logging.LogLevel.Debug"/> and namespace event ID offsets will be automatically appended
            </param>
            <param name="name">
            Distinctive (ideally unique) human-readable name for the log event.
            The name of the custom log method is usually preferrable (using <see langword="nameof"/>).
            </param>
            <param name="message">Format string of the log message.</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
        </member>
        <member name="M:UnityUtil.Logging.BaseUnityUtilLogger`1.LogInformation(System.Int32,System.String,System.String,System.Object[])">
            <summary>
            Formats and writes a log message at <see cref="F:Microsoft.Extensions.Logging.LogLevel.Information"/> level,
            with the specified <paramref name="id"/> and <paramref name="name"/>.
            </summary>
            <param name="id">
            Unique ID <i>within the logging namespace</i>.
            The <see cref="F:Microsoft.Extensions.Logging.LogLevel.Information"/> and namespace event ID offsets will be automatically appended
            </param>
            <param name="name">
            Distinctive (ideally unique) human-readable name for the log event.
            The name of the custom log method is usually preferrable (using <see langword="nameof"/>).
            </param>
            <param name="message">Format string of the log message.</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
        </member>
        <member name="M:UnityUtil.Logging.BaseUnityUtilLogger`1.LogWarning(System.Int32,System.String,System.String,System.Object[])">
            <summary>
            Formats and writes a log message at <see cref="F:Microsoft.Extensions.Logging.LogLevel.Warning"/> level,
            with the specified <paramref name="id"/> and <paramref name="name"/>.
            </summary>
            <param name="id">
            Unique ID <i>within the logging namespace</i>.
            The <see cref="F:Microsoft.Extensions.Logging.LogLevel.Warning"/> and namespace event ID offsets will be automatically appended
            </param>
            <param name="name">
            Distinctive (ideally unique) human-readable name for the log event.
            The name of the custom log method is usually preferrable (using <see langword="nameof"/>).
            </param>
            <param name="message">Format string of the log message.</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
        </member>
        <member name="M:UnityUtil.Logging.BaseUnityUtilLogger`1.LogError(System.Int32,System.String,System.String,System.Object[])">
            <summary>
            Formats and writes a log message at <see cref="F:Microsoft.Extensions.Logging.LogLevel.Error"/> level,
            with the specified <paramref name="id"/> and <paramref name="name"/>.
            </summary>
            <param name="id">
            Unique ID <i>within the logging namespace</i>.
            The <see cref="F:Microsoft.Extensions.Logging.LogLevel.Error"/> and namespace event ID offsets will be automatically appended
            </param>
            <param name="name">
            Distinctive (ideally unique) human-readable name for the log event.
            The name of the custom log method is usually preferrable (using <see langword="nameof"/>).
            </param>
            <param name="message">Format string of the log message.</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
        </member>
        <member name="M:UnityUtil.Logging.BaseUnityUtilLogger`1.LogCritical(System.Int32,System.String,System.String,System.Object[])">
            <summary>
            Formats and writes a log message at <see cref="F:Microsoft.Extensions.Logging.LogLevel.Critical"/> level,
            with the specified <paramref name="id"/> and <paramref name="name"/>.
            </summary>
            <param name="id">
            Unique ID <i>within the logging namespace</i>.
            The <see cref="F:Microsoft.Extensions.Logging.LogLevel.Critical"/> and namespace event ID offsets will be automatically appended
            </param>
            <param name="name">
            Distinctive (ideally unique) human-readable name for the log event.
            The name of the custom log method is usually preferrable (using <see langword="nameof"/>).
            </param>
            <param name="message">Format string of the log message.</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
        </member>
        <member name="M:UnityUtil.Logging.BaseUnityUtilLogger`1.Log(System.Int32,System.String,Microsoft.Extensions.Logging.LogLevel,System.String,System.Object[])">
            <summary>
            Formats and writes a log message at the specified <paramref name="logLevel"/>,
            with the specified <paramref name="id"/> and <paramref name="name"/>.
            </summary>
            <param name="id">
            Unique ID <i>within the logging namespace</i>.
            The <see cref="T:Microsoft.Extensions.Logging.LogLevel"/> and namespace event ID offsets will be automatically appended
            </param>
            <param name="name">
            Distinctive (ideally unique) human-readable name for the log event.
            The name of the custom log method is usually preferrable (using <see langword="nameof"/>).
            </param>
            <param name="logLevel">Entry will be written on this level.</param>
            <param name="message">Format string of the log message.</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
        </member>
        <member name="M:UnityUtil.Logging.BaseUnityUtilLogger`1.LogWarning(System.Int32,System.String,System.Exception,System.String,System.Object[])">
            <summary>
            Formats and writes a log message at <see cref="F:Microsoft.Extensions.Logging.LogLevel.Warning"/>,
            with the specified <paramref name="id"/> and <paramref name="name"/>.
            </summary>
            <param name="id">
            Unique ID <i>within the logging namespace</i>.
            The <see cref="F:Microsoft.Extensions.Logging.LogLevel.Warning"/> and namespace event ID offsets will be automatically appended
            </param>
            <param name="name">
            Distinctive (ideally unique) human-readable name for the log event.
            The name of the custom log method is usually preferrable (using <see langword="nameof"/>).
            </param>
            <param name="exception">The exception to log.</param>
            <param name="message">Format string of the log message.</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
        </member>
        <member name="M:UnityUtil.Logging.BaseUnityUtilLogger`1.LogError(System.Int32,System.String,System.Exception,System.String,System.Object[])">
            <summary>
            Formats and writes a log message at <see cref="F:Microsoft.Extensions.Logging.LogLevel.Error"/>,
            with the specified <paramref name="id"/> and <paramref name="name"/>.
            </summary>
            <param name="id">
            Unique ID <i>within the logging namespace</i>.
            The <see cref="F:Microsoft.Extensions.Logging.LogLevel.Error"/> and namespace event ID offsets will be automatically appended
            </param>
            <param name="name">
            Distinctive (ideally unique) human-readable name for the log event.
            The name of the custom log method is usually preferrable (using <see langword="nameof"/>).
            </param>
            <param name="exception">The exception to log.</param>
            <param name="message">Format string of the log message.</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
        </member>
        <member name="M:UnityUtil.Logging.BaseUnityUtilLogger`1.LogCritical(System.Int32,System.String,System.Exception,System.String,System.Object[])">
            <summary>
            Formats and writes a log message at <see cref="F:Microsoft.Extensions.Logging.LogLevel.Critical"/>,
            with the specified <paramref name="id"/> and <paramref name="name"/>.
            </summary>
            <param name="id">
            Unique ID <i>within the logging namespace</i>.
            The <see cref="F:Microsoft.Extensions.Logging.LogLevel.Critical"/> and namespace event ID offsets will be automatically appended
            </param>
            <param name="name">
            Distinctive (ideally unique) human-readable name for the log event.
            The name of the custom log method is usually preferrable (using <see langword="nameof"/>).
            </param>
            <param name="exception">The exception to log.</param>
            <param name="message">Format string of the log message.</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
        </member>
        <member name="M:UnityUtil.Logging.BaseUnityUtilLogger`1.Log(System.Int32,System.String,Microsoft.Extensions.Logging.LogLevel,System.Exception,System.String,System.Object[])">
            <summary>
            Formats and writes a log message at the specified <paramref name="logLevel"/>,
            with the specified <paramref name="id"/> and <paramref name="name"/>.
            </summary>
            <param name="id">
            Unique ID <i>within the logging namespace</i>.
            The <see cref="T:Microsoft.Extensions.Logging.LogLevel"/> and namespace event ID offsets will be automatically appended
            </param>
            <param name="name">
            Distinctive (ideally unique) human-readable name for the log event.
            The name of the custom log method is usually preferrable (using <see langword="nameof"/>).
            </param>
            <param name="logLevel">Entry will be written on this level.</param>
            <param name="exception">The exception to log.</param>
            <param name="message">Format string of the log message.</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
        </member>
        <member name="T:UnityUtil.Logging.LogLevelCallbackLogger">
            <summary>
            "Default" implementation of <see cref="T:Microsoft.Extensions.Logging.ILogger"/> that calls provided callbacks for log messages based on their <see cref="T:Microsoft.Extensions.Logging.LogLevel"/>.
            Mainly intended for testing code that needs to verify that loggers were invoked in specific ways.
            Most runtime code should still prefer dependency injection and one of the custom <see cref="N:UnityUtil"/> loggers.
            </summary>
        </member>
        <member name="M:UnityUtil.Logging.LogLevelCallbackLogger.#ctor(Microsoft.Extensions.Logging.LogLevel,System.Action{Microsoft.Extensions.Logging.LogLevel,Microsoft.Extensions.Logging.EventId,System.Exception,System.String},System.Action{Microsoft.Extensions.Logging.LogLevel,Microsoft.Extensions.Logging.EventId,System.Exception,System.String})">
            <summary>
            "Default" implementation of <see cref="T:Microsoft.Extensions.Logging.ILogger"/> that calls provided callbacks for log messages based on their <see cref="T:Microsoft.Extensions.Logging.LogLevel"/>.
            Mainly intended for testing code that needs to verify that loggers were invoked in specific ways.
            Most runtime code should still prefer dependency injection and one of the custom <see cref="N:UnityUtil"/> loggers.
            </summary>
        </member>
        <member name="T:UnityUtil.Logging.LogLevelCallbackLoggerFactory">
            <summary>
            "Default" implementation of <see cref="T:Microsoft.Extensions.Logging.ILoggerFactory"/> that creates instances of <see cref="T:UnityUtil.Logging.LogLevelCallbackLogger"/>.
            </summary>
        </member>
        <member name="M:UnityUtil.Logging.LogLevelCallbackLoggerFactory.#ctor(Microsoft.Extensions.Logging.LogLevel,System.Action{Microsoft.Extensions.Logging.LogLevel,Microsoft.Extensions.Logging.EventId,System.Exception,System.String},System.Action{Microsoft.Extensions.Logging.LogLevel,Microsoft.Extensions.Logging.EventId,System.Exception,System.String})">
            <summary>
            "Default" implementation of <see cref="T:Microsoft.Extensions.Logging.ILoggerFactory"/> that creates instances of <see cref="T:UnityUtil.Logging.LogLevelCallbackLogger"/>.
            </summary>
        </member>
        <member name="T:UnityUtil.Logging.UnityDebugLogger">
            <summary>
            "Default" implementation of <see cref="T:Microsoft.Extensions.Logging.ILogger"/> to wrap Unity's own <see cref="T:UnityEngine.Debug"/> <c>Log*</c> methods.
            Mainly intended for Unity code that can't set up a proper logging framework via dependency injection (e.g., in Editor scripts).
            Most runtime code should still prefer dependency injection and one of the custom <see cref="N:UnityUtil"/> loggers.
            </summary>
        </member>
        <member name="T:UnityUtil.Logging.UnityDebugLoggerFactory">
            <summary>
            "Default" implementation of <see cref="T:Microsoft.Extensions.Logging.ILoggerFactory"/> that creates instances of <see cref="T:UnityUtil.Logging.UnityDebugLogger"/>.
            </summary>
        </member>
        <member name="T:UnityUtil.QuantityEvent">
            <summary>
            Type arguments are (float oldValue, float newValue)
            </summary>
        </member>
        <member name="T:UnityUtil.Math.IRandomAdapter">
            <summary>
            Provides an interface around <see cref="T:System.Random"/> to allow for easier testing and dependency injection.
            </summary>
        </member>
        <member name="P:UnityUtil.Math.IRandomAdapter.Seed">
            <summary>
            The seed used to initialize <see cref="P:UnityUtil.Math.IRandomAdapter.Rand"/>
            </summary>
        </member>
        <member name="P:UnityUtil.Math.IRandomAdapter.Rand">
            <summary>
            The adapted <see cref="T:System.Random"/> instance
            </summary>
        </member>
        <member name="M:UnityUtil.Math.IRandomAdapter.NextInt">
            <summary>
            Returns a non-negative random integer.
            </summary>
            <returns>A 32-bit signed integer that is greater than or equal to 0 and less than <see cref="F:System.Int32.MaxValue"/>.</returns>
            <exception cref="T:System.InvalidOperationException"><see cref="P:UnityUtil.Math.IRandomAdapter.Rand"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:UnityUtil.Math.IRandomAdapter.NextDouble">
            <summary>
            Returns a random floating-point number that is greater than or equal to 0.0, and less than 1.0.
            </summary>
            <returns>A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</returns>
            <exception cref="T:System.InvalidOperationException"><see cref="P:UnityUtil.Math.IRandomAdapter.Rand"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:UnityUtil.Math.IRandomAdapter.Range(System.Int32,System.Int32)">
            <summary>
            Returns a random integer that is within a specified range.
            </summary>
            <param name="inclusiveMin">The inclusive lower bound of the random number returned.</param>
            <param name="exclusiveMax">The exclusive upper bound of the random number returned. <paramref name="exclusiveMax"/> must be greater than or equal to <paramref name="inclusiveMin"/>.</param>
            <returns>
            A 32-bit signed integer greater than or equal to <paramref name="inclusiveMin"/> and less than <paramref name="exclusiveMax"/>;
            that is, the range of return values includes <paramref name="inclusiveMin"/> but not <paramref name="exclusiveMax"/>.
            If <paramref name="inclusiveMin"/> equals <paramref name="exclusiveMax"/>, then <paramref name="inclusiveMin"/> is returned.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="inclusiveMin"/> is greater than <paramref name="exclusiveMax"/>.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:UnityUtil.Math.IRandomAdapter.Rand"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:UnityUtil.Math.IRandomAdapter.Range(System.Single,System.Single)">
            <summary>
            Returns a random floating-point number that is within a specified range.
            </summary>
            <param name="inclusiveMin">The inclusive lower bound of the random number returned.</param>
            <param name="exclusiveMax">The exclusive upper bound of the random number returned.</param>
            <returns>
            A floating point number greater than or equal to <paramref name="inclusiveMin"/> and less than <paramref name="exclusiveMax"/>;
            that is, the range of return values includes <paramref name="inclusiveMin"/> but not <paramref name="exclusiveMax"/>.
            If <paramref name="inclusiveMin"/> equals <paramref name="exclusiveMax"/>, then <paramref name="inclusiveMin"/> is returned.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="inclusiveMin"/> is greater than <paramref name="exclusiveMax"/>.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:UnityUtil.Math.IRandomAdapter.Rand"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:UnityUtil.Math.IRandomAdapter.Range(System.Double,System.Double)">
            <summary>
            Returns a random floating-point number that is within a specified range.
            </summary>
            <param name="inclusiveMin">The inclusive lower bound of the random number returned.</param>
            <param name="exclusiveMax">The exclusive upper bound of the random number returned.</param>
            <returns>
            A floating point number greater than or equal to <paramref name="inclusiveMin"/> and less than <paramref name="exclusiveMax"/>;
            that is, the range of return values includes <paramref name="inclusiveMin"/> but not <paramref name="exclusiveMax"/>.
            If <paramref name="inclusiveMin"/> equals <paramref name="exclusiveMax"/>, then <paramref name="inclusiveMin"/> is returned.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="inclusiveMin"/> is greater than <paramref name="exclusiveMax"/>.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:UnityUtil.Math.IRandomAdapter.Rand"/> is <see langword="null"/>.</exception>
        </member>
        <member name="T:UnityUtil.Math.IRandomishOptionChooser">
            <summary>
            Chooses between options in a "randomish" way, i.e., a way that <em>feels</em> random to humans over time but may not be truly (psuedo)random.
            </summary>
        </member>
        <member name="M:UnityUtil.Math.IRandomishOptionChooser.GetOptionIndex">
            <summary>
            Chooses an option index in a "randomish" way, i.e., a way that <em>feels</em> random to humans over time but may not be truly (psuedo)random.
            </summary>
            <returns>
            An index between 0 (inclusive) and the number of options (exclusive).
            </returns>
        </member>
        <member name="T:UnityUtil.Math.MathLogger`1">
            <inheritdoc/>
        </member>
        <member name="T:UnityUtil.Math.MaxRepeatsRandomishOptionChooser">
            <summary>
            <para>
            Chooses between options in a "randomish" way, i.e., a way that <em>feels</em> random to humans over time but is not truly random.
            Achieved by repeating options some max number of times in a row.
            </para>
            <para>
            This type is not thread safe. If randomish option indices must be accessed by multiple threads, you will need to implement your own synchronization mechanism.
            </para>
            </summary>
        </member>
        <member name="F:UnityUtil.Math.MaxRepeatsRandomishOptionChooser.ProbabilitySumTolerance">
            <summary>
            All <see cref="P:UnityUtil.Math.MaxRepeatsRandomishOptionChooserConfig.OptionProbabilities"/> must sum to 1, within this tolerance.
            This accounts for probabilities that cannot be accurately represented with floating point numbers (e.g., 1/9).
            </summary>
        </member>
        <member name="P:UnityUtil.Math.MaxRepeatsRandomishOptionChooser.OptionRepeats">
            <summary>
            Number of times the option at each index has been repeated during the last <see cref="P:UnityUtil.Math.MaxRepeatsRandomishOptionChooserConfig.MaxRepeats"/> calls to <see cref="M:UnityUtil.Math.MaxRepeatsRandomishOptionChooser.GetOptionIndex"/>.
            </summary>
        </member>
        <member name="M:UnityUtil.Math.MaxRepeatsRandomishOptionChooser.GetOptionIndex">
            <summary>
            Chooses an option index using "randomish" logic.
            This is an O(n) operation, where n is the number of options.
            </summary>
            <returns>
            An index between 0 (inclusive) and the number of options (exclusive).
            </returns>
            <remarks>
            <para>
            Indices are chosen using the configured <see cref="P:UnityUtil.Math.MaxRepeatsRandomishOptionChooserConfig.OptionProbabilities"/>
            while ensuring that no option is returned more than <see cref="P:UnityUtil.Math.MaxRepeatsRandomishOptionChooserConfig.MaxRepeats"/> times in a row.
            For example, suppose [0.3, 0.4, 0.3] are the specified probabilities, with a max repeat of 3.
            Initially, there is a 30% chance of returning 0, 40% chance of returning 1, and 30% chance of returning 2.
            If index 1 is returned 3 times in a row, then on the next call, there will instead be a 50% chance of returning 0 and a 50% chance of returning 2
            (maintaining the relative probabilities of those options, while preventing 1 from being returned again).
            On the next call, index 1 has no longer been returned 3 times in a row, so the probabilties go back to their initial values.
            </para>
            <para>
            To understand this method's logic, picture a set of ranges between 0 and 1, with sizes determined by the <see cref="P:UnityUtil.Math.MaxRepeatsRandomishOptionChooserConfig.OptionProbabilities"/>.
            </para>
            <code>
            |-------|----------------------|---|--------|
            |------------------^------------------------|
            </code>
            <para>
            The caret represents a random value, R, between 0 and 1 (inclusive).
            The probability of choosing option i (0-based), according to the specified probabilities,
            equals the probability of R falling within the (i+1)th range (where each range includes its left bound).
            E.g., the probability of choosing index 1 equals the probability of R falling within the 2nd range.
            Therefore, the index at which the cumulative probability of <see cref="P:UnityUtil.Math.MaxRepeatsRandomishOptionChooserConfig.OptionProbabilities"/> is greater than R is the "chosen" index.
            </para>
            <para>
            <see cref="T:UnityUtil.Math.MaxRepeatsRandomishOptionChooser"/> maintains a collection of the last <see cref="P:UnityUtil.Math.MaxRepeatsRandomishOptionChooserConfig.MaxRepeats"/> indices returned.
            When an option has been chosen more than the max allowed times in a row, its probability is temporarily zero.
            In the above visualization, this is equivalent to collapsing that option's interval to zero width, and then restricting R
            to the range between 0 and (1 - that option's probability).
            </para>
            </remarks>
        </member>
        <member name="M:UnityUtil.Math.MaxRepeatsRandomishOptionChooser.UseOption(System.Int32)">
            <summary>
            Adjust state after the option at <paramref name="index"/> is chosen.
            </summary>
            <param name="index">Index of the option that was chosen.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is out of bounds of the <see cref="P:UnityUtil.Math.MaxRepeatsRandomishOptionChooser.OptionRepeats"/> list.</exception>
            <exception cref="T:System.InvalidOperationException">Option at <paramref name="index"/> has already been repeated the max of <see cref="P:UnityUtil.Math.MaxRepeatsRandomishOptionChooserConfig.MaxRepeats"/> times in a row.</exception>
        </member>
        <member name="M:UnityUtil.Math.MoreMath.RandomWeightedIndex(System.Collections.Generic.IReadOnlyList{System.Single},UnityUtil.Math.IRandomAdapter)">
            <summary>
            Gets a random index where each index has a provided weight. For example, if [0.3, 0.4, 0.3] is provided, then
            there is a 30% chance of returning 0, 40% chance of returning 1, and 30% chance of returning 2.
            </summary>
            <param name="indexWeights">The weights for each index. These must sum up to 1.</param>
            <param name="randomAdapter">The object used to generate pseudorandom numbers.</param>
            <returns>An index between 0 (inclusive) and the length of <paramref name="indexWeights"/> (exclusive)</returns>
            <exception cref="T:System.ArgumentException"><paramref name="indexWeights"/> is empty.</exception>
            <exception cref="T:System.InvalidOperationException">The sum of <paramref name="indexWeights"/> is not 1.</exception>
            <remarks>
            Picture a set of ranges between 0 and 1, with sizes determined by <paramref name="indexWeights"/>
            <code>
            |-------|----------------------|---|--------|
            |------------------^------------------------|
            </code>
            The caret represents a random value, R, between 0 and 1 (inclusive).
            The probability of choosing index i (0-based), according to the specified weights,
            equals the probability of R falling within the (i+1)th range (where each range includes its left bound).
            E.g., the probability of choosing index 1 equals the probability of R falling within the 2nd range.
            Therefore, the index at which the cumulative probability of <paramref name="indexWeights"/> is greater than R is our "chosen" index.
            </remarks>
        </member>
        <member name="M:UnityUtil.Math.MoreMath.RandomUniqueIndices(System.Int32,System.Int32,UnityUtil.Math.IRandomAdapter)">
            <summary>
            Returns a set of <paramref name="count"/> unique random indices into a collection with the provided <paramref name="sourceCount"/>.
            Order of the returned indices is unspecified. Note that this method allocates a block of memory that
            scales linearly (O(n)) with <paramref name="sourceCount"/>.
            </summary>
            <param name="count">The number of unique random indices to return.</param>
            <param name="sourceCount">The number of elements in the source collection into which we are returning random indices.</param>
            <param name="randomAdapter">The object used to generate pseudorandom numbers.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> or <paramref name="sourceCount"/> is less than zero.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="count"/> is greater than <paramref name="sourceCount"/>.</exception>
        </member>
        <member name="M:UnityUtil.Math.MoreMath.RandomConeVector(UnityEngine.Transform,System.Single,System.Boolean)">
            <summary>
            Returns a random unit vector within a cone of the provided half-angle around the provided <see cref="T:UnityEngine.Transform"/>'s forward vector (uniformly distributed).
            </summary>
            <param name="transform">The <see cref="T:UnityEngine.Transform"/> around whose forward vector the cone is centered</param>
            <param name="halfAngle">The half angle (in degrees) of the cone</param>
            <param name="onlyBoundary">If <see langword="true"/>, then the random unit vector will be constrained to the boundary of the cone.  If <see langword="false"/>, then the random unit vector may be anywhere within the cone.</param>
            <returns>A random unit vector within a cone of the provided half-angle around the provided <see cref="T:UnityEngine.Transform"/>'s forward vector (uniformly distributed).</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="halfAngle"/> is less then 0° or greater than or equal to 360°.</exception>
        </member>
        <member name="M:UnityUtil.Math.MoreMath.RandomConeVector(UnityEngine.Vector3,System.Single,System.Boolean)">
            <summary>
            Returns a random unit vector within a cone of the provided half-angle centered around the provided axis (uniformly distributed).
            </summary>
            <param name="axis">The center axis of the cone</param>
            <param name="halfAngle">The half angle (in degrees) of the cone</param>
            <param name="onlyBoundary">If <see langword="true"/>, then the random unit vector will be constrained to the boundary of the cone.  If <see langword="false"/>, then the random unit vector may be anywhere within the cone.</param>
            <returns>A random unit vector within a cone of the provided half-angle around the provided <see cref="T:UnityEngine.Transform"/>'s forward vector (uniformly distributed).</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="halfAngle"/> is less then 0° or greater than or equal to 360°.</exception>
        </member>
        <member name="P:UnityUtil.Math.RandomAdapter.Seed">
            <inheritdoc/>
        </member>
        <member name="P:UnityUtil.Math.RandomAdapter.Rand">
            <inheritdoc/>
        </member>
        <member name="P:UnityUtil.Math.UniformBatchedRandomishOptionChooserConfig.OptionCount">
            <summary>
            Number of equally likely options that can be chosen. Must be 1 or greater.
            </summary>
        </member>
        <member name="P:UnityUtil.Math.UniformBatchedRandomishOptionChooserConfig.MinRunsPerBatch">
            <summary>
            Minimum number of runs (sequences of repeated options) allowed per batch. Must be 0 or greater and less than <see cref="P:UnityUtil.Math.UniformBatchedRandomishOptionChooserConfig.MaxRunsPerBatch"/>.
            </summary>
        </member>
        <member name="P:UnityUtil.Math.UniformBatchedRandomishOptionChooserConfig.MaxRunsPerBatch">
            <summary>
            Maximum number of runs (sequences of repeated options) allowed per batch. Must be greater than or equal to <see cref="P:UnityUtil.Math.UniformBatchedRandomishOptionChooserConfig.MinRunsPerBatch"/>.
            </summary>
        </member>
        <member name="P:UnityUtil.Math.UniformBatchedRandomishOptionChooserConfig.MaxRepeatsPerRun">
            <summary>
            Maximum number of times an option can be repeated in a run, i.e., the max "length" of a run.
            Minimum number of repeats per run is obviously 1, so <see cref="P:UnityUtil.Math.UniformBatchedRandomishOptionChooserConfig.MaxRepeatsPerRun"/> must be greater than 1.
            </summary>
        </member>
        <member name="T:UnityUtil.Math.UniformBatchedRandomishOptionChooser">
            <summary>
            <para>
            Chooses between options in a "randomish" way, i.e., a way that <em>feels</em> random to humans over time but is not truly random.
            Achieved by generating "batches" of options in advance with configurable numbers/lengths of runs.
            All options are assumbed to be equally likely; they will have a "uniform" distribution over time.
            </para>
            <para>
            This type is not thread safe. If randomish option indices must be accessed by multiple threads, you will need to implement your own synchronization mechanism.
            </para>
            </summary>
        </member>
        <member name="P:UnityUtil.Math.UniformBatchedRandomishOptionChooser.BatchProviderDelegate">
            <summary>
            The delegate that will provide the next batch of option indices. Defaults to <see cref="M:UnityUtil.Math.UniformBatchedRandomishOptionChooser.GetBatch"/>.
            <strong>This property should only be explicitly set in unit tests!</strong>
            </summary>
        </member>
        <member name="F:UnityUtil.Math.UniformBatchedRandomishOptionChooser.LastOptionIndexOfPreviousBatch">
            <summary>
            <see cref="M:UnityUtil.Math.UniformBatchedRandomishOptionChooser.GetBatch"/> will ensure that this index is not chosen at the start of a batch,
            to prevent accidentally "continuing" a run across batches.
            <strong>This property should only be explicitly set in unit tests!</strong>
            </summary>
        </member>
        <member name="M:UnityUtil.Math.UniformBatchedRandomishOptionChooser.GetOptionIndex">
            <inheritdoc/>
        </member>
        <member name="T:UnityUtil.MultiCollection`2">
            <summary>
            Represents a strongly typed list of objects with constant-time insertion, removal, and duplicate checks,
            as well as low-overhead iteration, at the cost of additional memory.
            </summary>
            <typeparam name="TKey">The type of the keys in the collection.</typeparam>
            <typeparam name="TValue">The type of the values in the collection.</typeparam>
        </member>
        <member name="M:UnityUtil.MultiCollection`2.TrimExcess">
            <summary>
            Sets the capacity to the actual number of elements in the underlying collection, to save on memory.
            </summary>
        </member>
        <member name="T:UnityUtil.RootLogger`1">
            <inheritdoc/>
        </member>
        <member name="T:UnityUtil.RuntimeIdProvider">
            <inheritdoc/>
        </member>
        <member name="M:UnityUtil.RuntimeIdProvider.GetId">
            <inheritdoc/>
        </member>
        <member name="T:UnityUtil.ShowBackingFieldAttribute">
            <summary>
            Force Unity to serialize the backing field of a C# auto-implemented property.
            Consuming properties should be declared as follows
            (note that both a getter and a setter are required for Unity to recognize the backing field):
            <code>
            [field: SerializeBackingField]
            public SomeType SomeProperty { get; private set; }
            </code>
            </summary>
        </member>
        <member name="T:UnityUtil.SpawnDirection">
            <summary>
            Determines the direction in which <see cref="F:UnityUtil.Spawner.Prefab"/> instances spawned by a <see cref="T:UnityUtil.Spawner"/> are launched.
            </summary>
        </member>
        <member name="F:UnityUtil.SpawnDirection.Straight">
            <summary>
            Spawned <see cref="F:UnityUtil.Spawner.Prefab"/> instances will be launched along the <see cref="T:UnityUtil.Spawner"/>'s forward vector.
            </summary>
        </member>
        <member name="F:UnityUtil.SpawnDirection.ConeRandom">
            <summary>
            Spawned <see cref="F:UnityUtil.Spawner.Prefab"/> instances will be launched along a random vector within a cone centered around the <see cref="T:UnityUtil.Spawner"/>'s forward vector.
            </summary>
        </member>
        <member name="F:UnityUtil.SpawnDirection.ConeBoundary">
            <summary>
            Spawned <see cref="F:UnityUtil.Spawner.Prefab"/> instances will be launched along a random vector on the boundary of a cone centered around the <see cref="T:UnityUtil.Spawner"/>'s forward vector.
            </summary>
        </member>
        <member name="F:UnityUtil.SpawnDirection.AnyDirection">
            <summary>
            Spawned <see cref="F:UnityUtil.Spawner.Prefab"/> instances will be launched along any random vector.
            </summary>
        </member>
        <member name="M:UnityUtil.Storage.ILocalPreferences.DeleteAll">
            <summary>
            Removes all keys and values from the preferences. Use with caution.
            </summary>
        </member>
        <member name="M:UnityUtil.Storage.ILocalPreferences.DeleteKey(System.String)">
            <summary>
            Removes key and its corresponding value from the preferences.
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:UnityUtil.Storage.ILocalPreferences.GetFloat(System.String,System.Single)">
            <summary>
            Returns the value corresponding to key in the preference file if it exists; otherwise, <paramref name="defaultValue"/>.
            </summary>
            <param name="key"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnityUtil.Storage.ILocalPreferences.GetFloat(System.String)">
            <summary>
            Returns the value corresponding to key in the preference file if it exists; otherwise, zero.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:UnityUtil.Storage.ILocalPreferences.GetInt(System.String,System.Int32)">
            <summary>
            Returns the value corresponding to key in the preference file if it exists; otherwise, <paramref name="defaultValue"/>.
            </summary>
            <param name="key"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnityUtil.Storage.ILocalPreferences.GetInt(System.String)">
            <summary>
            Returns the value corresponding to key in the preference file if it exists; otherwise, zero.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:UnityUtil.Storage.ILocalPreferences.GetString(System.String,System.String)">
            <summary>
            Returns the value corresponding to key in the preference file if it exists; otherwise, <paramref name="defaultValue"/>.
            </summary>
            <param name="key"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:UnityUtil.Storage.ILocalPreferences.GetString(System.String)">
            <summary>
            Returns the value corresponding to key in the preference file if it exists; otherwise, <see cref="F:System.String.Empty"/>.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:UnityUtil.Storage.ILocalPreferences.HasKey(System.String)">
            <summary>
            Returns true if key exists in the preferences.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:UnityUtil.Storage.ILocalPreferences.Save">
            <summary>
            Writes all modified preferences to disk.
            </summary>
        </member>
        <member name="M:UnityUtil.Storage.ILocalPreferences.SetFloat(System.String,System.Single)">
            <summary>
            Sets the value of the preference identified by key.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:UnityUtil.Storage.ILocalPreferences.SetInt(System.String,System.Int32)">
            <summary>
            Sets the value of the preference identified by key.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:UnityUtil.Storage.ILocalPreferences.SetString(System.String,System.String)">
            <summary>
            Sets the value of the preference identified by key.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:UnityUtil.UnityObjectExtensions.AssertActiveAndEnabled(UnityEngine.Behaviour,System.String)">
            <summary>
            Assert that this component is both active and enabled.
            </summary>
            <param name="behaviour">The <see cref="T:UnityEngine.Behaviour"/> to assert as active and enabled</param>
            <param name="verbMessage">
            If this component is either inactive or disabled, then this verb will be used in the logged error message.
            Should be present-tense phrase, like "stop", or "perform that action". Padding spaces are not required.
            </param>
        </member>
        <member name="T:UnityUtil.Updating.IUnityMainThreadDispatcher">
            <summary>
            Original author: Pim de Witte (pimdewitte.com) and contributors, https://github.com/PimDeWitte/UnityMainThreadDispatcher.
            Encapsulates a thread-safe queue with actions to execute on the next update loop.
            It can be used to make calls to Unity's main thread for things such as UI manipulation.
            It was developed for use in combination with the Firebase Unity plugin, which uses separate threads for event handling.
            </summary>
        </member>
        <member name="M:UnityUtil.Updating.IUnityMainThreadDispatcher.Enqueue(System.Action)">
            <summary>
            Locks the queue and adds <paramref name="action"/> to the queue
            </summary>
            <param name="action">Action that will be executed from Unity's main thread.</param>
        </member>
        <member name="M:UnityUtil.Updating.IUnityMainThreadDispatcher.EnqueueAsync(System.Action)">
            <summary>
            Locks the queue and adds <paramref name="action"/> to the queue, returning a <see cref="T:System.Threading.Tasks.Task"/> which is completed when the action completes
            </summary>
            <param name="action">Action that will be executed from Unity's main thread.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> that can be awaited until the action completes</returns>
        </member>
        <member name="M:UnityUtil.Updating.IUpdater.RegisterUpdate(System.Int32,System.Action{System.Single})">
            <summary>
            Register an <see cref="T:System.Action"/> to be called every frame for the component with a given instance ID.
            </summary>
            <param name="instanceId">The instance ID of the component that will be updated every frame. Must be unique among all registered instances.</param>
            <param name="updateAction">The <see cref="T:System.Action"/> to be called every frame.</param>
            <exception cref="T:System.InvalidOperationException">An Update <see cref="T:System.Action"/> has already been registered for <paramref name="instanceId"/>.</exception>
        </member>
        <member name="M:UnityUtil.Updating.IUpdater.UnregisterUpdate(System.Int32)">
            <summary>
            Unregister an <see cref="T:System.Action"/> from being called every frame for the component with the specified instance ID.
            </summary>
            <param name="instanceId">
            The instance ID of the component that no longer needs to be updated every frame.
            Must have been previously registered with <see cref="M:UnityUtil.Updating.IUpdater.RegisterUpdate(System.Int32,System.Action{System.Single})"/>.
            </param>
            <exception cref="T:System.InvalidOperationException">No Update <see cref="T:System.Action"/> was ever registered for <paramref name="instanceId"/>.</exception>
        </member>
        <member name="M:UnityUtil.Updating.IUpdater.RegisterFixedUpdate(System.Int32,System.Action{System.Single})">
            <summary>
            Register an <see cref="T:System.Action"/> to be called physics every frame for the component with the specified instance ID.
            </summary>
            <param name="instanceId">The instance ID of the component that will be updated every physics frame. Must be unique among all registered instances.</param>
            <param name="fixedUpdateAction">The <see cref="T:System.Action"/> to be called every physics frame.</param>
            <exception cref="T:System.InvalidOperationException">A FixedUpdate <see cref="T:System.Action"/> has already been registered for <paramref name="instanceId"/>.</exception>
        </member>
        <member name="M:UnityUtil.Updating.IUpdater.UnregisterFixedUpdate(System.Int32)">
            <summary>
            Unregister an <see cref="T:System.Action"/> from being called every physics frame for the component with the specified instance ID.
            </summary>
            <param name="instanceId">
            The instance ID of the component that no longer needs to be updated every physics frame.
            Must have been previously registered with <see cref="M:UnityUtil.Updating.IUpdater.RegisterFixedUpdate(System.Int32,System.Action{System.Single})"/>.
            </param>
            <exception cref="T:System.InvalidOperationException">No FixedUpdate <see cref="T:System.Action"/> was ever registered for <paramref name="instanceId"/>.</exception>
        </member>
        <member name="M:UnityUtil.Updating.IUpdater.RegisterLateUpdate(System.Int32,System.Action{System.Single})">
            <summary>
            Register an <see cref="T:System.Action"/> to be called at the end of every frame for the component with the specified instance ID.
            </summary>
            <param name="instanceId">The instance ID of the component that will be updated at the end of every frame. Must be unique among all registered instances.</param>
            <param name="lateUpdateAction">The <see cref="T:System.Action"/> to be called at the end of every frame.</param>
            <exception cref="T:System.InvalidOperationException">A LateUpdate <see cref="T:System.Action"/> has already been registered for <paramref name="instanceId"/>.</exception>
        </member>
        <member name="M:UnityUtil.Updating.IUpdater.UnregisterLateUpdate(System.Int32)">
            <summary>
            Unregister an <see cref="T:System.Action"/> from being called at the end of every frame for the component with the specified instance ID.
            </summary>
            <param name="instanceId">
            The instance ID of the component that no longer needs to be updated at the end of every frame.
            Must have been previously registered with <see cref="M:UnityUtil.Updating.IUpdater.RegisterLateUpdate(System.Int32,System.Action{System.Single})"/>.
            </param>
            <exception cref="T:System.InvalidOperationException">No LateUpdate <see cref="T:System.Action"/> was ever registered for <paramref name="instanceId"/>.</exception>
        </member>
        <member name="M:UnityUtil.Updating.IUpdater.TrimStorage">
            <summary>
            Sets the capacity of all underlying collections to the actual number of elements in those collections.
            Depending on implementation, there may be separate collections for Update actions, FixedUpdate actions, etc.,
            the memory of which are all auto-allocated as more actions are added.
            Trimming the capacity of these collections is thus an important way of saving memory, e.g., after several updatable
            objects have been destroyed.
            </summary>
        </member>
        <member name="T:UnityUtil.Updating.UnityMainThreadDispatcher">
            <summary>
            Original author: Pim de Witte (pimdewitte.com) and contributors, https://github.com/PimDeWitte/UnityMainThreadDispatcher.
            A thread-safe class which holds a queue with actions to execute on the next update loop.
            It can be used to make calls to Unity's main thread for things such as UI manipulation.
            It was developed for use in combination with the Firebase Unity plugin, which uses separate threads for event handling.
            </summary>
        </member>
        <member name="M:UnityUtil.Updating.UnityMainThreadDispatcher.Enqueue(System.Action)">
            <inheritdoc/>
        </member>
        <member name="M:UnityUtil.Updating.UnityMainThreadDispatcher.EnqueueAsync(System.Action)">
            <inheritdoc/>
        </member>
        <member name="T:UnityUtil.Updating.Updatable">
            <summary>
            Base class for components that need to register with the UnityUtil update system.
            </summary>
        </member>
        <member name="P:UnityUtil.Updating.Updatable.InstanceId">
            <summary>
            Runtime instance ID of this component, used internally to register actions with the update system.
            Inheritors may use this value so they don't have to add duplicate dependencies on an <see cref="T:UnityUtil.IRuntimeIdProvider"/>.
            </summary>
        </member>
        <member name="M:UnityUtil.Updating.Updatable.RegisterUpdate(System.Action{System.Single})">
            <summary>
            Register <paramref name="action"/> to be called during <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.Update.html"><c>Update</c></a>.
            It will automatically be unsubscribed and resubscribed as the component is disabled (or destroyed) and re-enabled.
            </summary>
            <param name="action">The action to be called during Update</param>
        </member>
        <member name="M:UnityUtil.Updating.Updatable.RegisterFixedUpdate(System.Action{System.Single})">
            <summary>
            Register <paramref name="action"/> to be called during <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html"><c>FixedUpdate</c></a>.
            It will automatically be unsubscribed and resubscribed as the component is disabled (or destroyed) and re-enabled.
            </summary>
            <param name="action">The action to be called during FixedUpdate</param>
        </member>
        <member name="M:UnityUtil.Updating.Updatable.RegisterLateUpdate(System.Action{System.Single})">
            <summary>
            Register <paramref name="action"/> to be called during <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.LateUpdate.html"><c>LateUpdate</c></a>.
            It will automatically be unsubscribed and resubscribed as the component is disabled (or destroyed) and re-enabled.
            </summary>
            <param name="action">The action to be called during LateUpdate</param>
        </member>
        <member name="M:UnityUtil.Updating.Updatable.UnregisterUpdate">
            <summary>
            Unregister this component's <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.Update.html"><c>Update</c></a> action.
            </summary>
            <exception cref="T:System.InvalidOperationException">No <c>Update</c> action was ever registered for this component.</exception>
        </member>
        <member name="M:UnityUtil.Updating.Updatable.UnregisterFixedUpdate">
            <summary>
            Unregister this component's <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html"><c>FixedUpdate</c></a> action.
            </summary>
            <exception cref="T:System.InvalidOperationException">No <c>FixedUpdate</c> action was ever registered for this component.</exception>
        </member>
        <member name="M:UnityUtil.Updating.Updatable.UnregisterLateUpdate">
            <summary>
            Unregister this component's <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.LateUpdate.html"><c>LateUpdate</c></a> action.
            </summary>
            <exception cref="T:System.InvalidOperationException">No <c>LateUpdate</c> action was ever registered for this component.</exception>
        </member>
    </members>
</doc>
